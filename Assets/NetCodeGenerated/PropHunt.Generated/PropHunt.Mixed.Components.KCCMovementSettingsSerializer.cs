//THIS FILE IS AUTOGENERATED BY GHOSTCOMPILER. DON'T MODIFY OR ALTER.
using System;
using AOT;
using Unity.Burst;
using Unity.Networking.Transport;
using Unity.NetCode.LowLevel.Unsafe;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Collections;
using Unity.NetCode;
using Unity.Transforms;
using Unity.Mathematics;
using PropHunt.Mixed.Components;

namespace PropHunt.Generated
{
    [BurstCompile]
    public struct PropHuntMixedComponentsKCCMovementSettingsGhostComponentSerializer
    {
        static PropHuntMixedComponentsKCCMovementSettingsGhostComponentSerializer()
        {
            State = new GhostComponentSerializer.State
            {
                GhostFieldsHash = 752026306206115913,
                ExcludeFromComponentCollectionHash = 0,
                ComponentType = ComponentType.ReadWrite<PropHunt.Mixed.Components.KCCMovementSettings>(),
                ComponentSize = UnsafeUtility.SizeOf<PropHunt.Mixed.Components.KCCMovementSettings>(),
                SnapshotSize = UnsafeUtility.SizeOf<Snapshot>(),
                ChangeMaskBits = ChangeMaskBits,
                SendMask = GhostComponentSerializer.SendMask.Interpolated | GhostComponentSerializer.SendMask.Predicted,
                SendForChildEntities = 1,
                CopyToSnapshot =
                    new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyToSnapshot),
                CopyFromSnapshot =
                    new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyFromSnapshot),
                RestoreFromBackup =
                    new PortableFunctionPointer<GhostComponentSerializer.RestoreFromBackupDelegate>(RestoreFromBackup),
                PredictDelta = new PortableFunctionPointer<GhostComponentSerializer.PredictDeltaDelegate>(PredictDelta),
                CalculateChangeMask =
                    new PortableFunctionPointer<GhostComponentSerializer.CalculateChangeMaskDelegate>(
                        CalculateChangeMask),
                Serialize = new PortableFunctionPointer<GhostComponentSerializer.SerializeDelegate>(Serialize),
                Deserialize = new PortableFunctionPointer<GhostComponentSerializer.DeserializeDelegate>(Deserialize),
                #if UNITY_EDITOR || DEVELOPMENT_BUILD
                ReportPredictionErrors = new PortableFunctionPointer<GhostComponentSerializer.ReportPredictionErrorsDelegate>(ReportPredictionErrors),
                #endif
            };
            #if UNITY_EDITOR || DEVELOPMENT_BUILD
            State.NumPredictionErrorNames = GetPredictionErrorNames(ref State.PredictionErrorNames);
            #endif
        }
        public static readonly GhostComponentSerializer.State State;
        public struct Snapshot
        {
            public int moveSpeed;
            public int sprintMultiplier;
            public int moveMaxBounces;
            public int moveAnglePower;
            public int movePushPower;
            public int movePushDecay;
            public int fallMaxBounces;
            public int fallPushPower;
            public int fallAnglePower;
            public int fallPushDecay;
            public float characterCenter_x;
            public float characterCenter_y;
            public float characterCenter_z;
        }
        public const int ChangeMaskBits = 11;
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyToSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData, snapshotOffset + snapshotStride*i);
                ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.KCCMovementSettings>(componentData, componentStride*i);
                ref var serializerState = ref GhostComponentSerializer.TypeCast<GhostSerializerState>(stateData, 0);
                snapshot.moveSpeed = (int) math.round(component.moveSpeed * 100);
                snapshot.sprintMultiplier = (int) math.round(component.sprintMultiplier * 100);
                snapshot.moveMaxBounces = (int) component.moveMaxBounces;
                snapshot.moveAnglePower = (int) math.round(component.moveAnglePower * 100);
                snapshot.movePushPower = (int) math.round(component.movePushPower * 100);
                snapshot.movePushDecay = (int) math.round(component.movePushDecay * 100);
                snapshot.fallMaxBounces = (int) component.fallMaxBounces;
                snapshot.fallPushPower = (int) math.round(component.fallPushPower * 100);
                snapshot.fallAnglePower = (int) math.round(component.fallAnglePower * 100);
                snapshot.fallPushDecay = (int) math.round(component.fallPushDecay * 100);
                snapshot.characterCenter_x = component.characterCenter.x;
                snapshot.characterCenter_y = component.characterCenter.y;
                snapshot.characterCenter_z = component.characterCenter.z;
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshotInterpolationData = ref GhostComponentSerializer.TypeCast<SnapshotData.DataAtTick>(snapshotData, snapshotStride*i);
                ref var snapshotBefore = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotBefore, snapshotOffset);
                ref var snapshotAfter = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotAfter, snapshotOffset);
                float snapshotInterpolationFactor = snapshotInterpolationData.InterpolationFactor;
                ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.KCCMovementSettings>(componentData, componentStride*i);
                var deserializerState = GhostComponentSerializer.TypeCast<GhostDeserializerState>(stateData, 0);
                deserializerState.SnapshotTick = snapshotInterpolationData.Tick;
                component.moveSpeed =
                    math.lerp(snapshotBefore.moveSpeed * 0.01f,
                        snapshotAfter.moveSpeed * 0.01f, snapshotInterpolationFactor);
                component.sprintMultiplier =
                    math.lerp(snapshotBefore.sprintMultiplier * 0.01f,
                        snapshotAfter.sprintMultiplier * 0.01f, snapshotInterpolationFactor);
                component.moveMaxBounces = (int) snapshotBefore.moveMaxBounces;
                component.moveAnglePower =
                    math.lerp(snapshotBefore.moveAnglePower * 0.01f,
                        snapshotAfter.moveAnglePower * 0.01f, snapshotInterpolationFactor);
                component.movePushPower =
                    math.lerp(snapshotBefore.movePushPower * 0.01f,
                        snapshotAfter.movePushPower * 0.01f, snapshotInterpolationFactor);
                component.movePushDecay =
                    math.lerp(snapshotBefore.movePushDecay * 0.01f,
                        snapshotAfter.movePushDecay * 0.01f, snapshotInterpolationFactor);
                component.fallMaxBounces = (int) snapshotBefore.fallMaxBounces;
                component.fallPushPower =
                    math.lerp(snapshotBefore.fallPushPower * 0.01f,
                        snapshotAfter.fallPushPower * 0.01f, snapshotInterpolationFactor);
                component.fallAnglePower =
                    math.lerp(snapshotBefore.fallAnglePower * 0.01f,
                        snapshotAfter.fallAnglePower * 0.01f, snapshotInterpolationFactor);
                component.fallPushDecay =
                    math.lerp(snapshotBefore.fallPushDecay * 0.01f,
                        snapshotAfter.fallPushDecay * 0.01f, snapshotInterpolationFactor);
                component.characterCenter = new float3(snapshotBefore.characterCenter_x, snapshotBefore.characterCenter_y, snapshotBefore.characterCenter_z);
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.RestoreFromBackupDelegate))]
        private static void RestoreFromBackup(IntPtr componentData, IntPtr backupData)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.KCCMovementSettings>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.KCCMovementSettings>(backupData, 0);
            component.moveSpeed = backup.moveSpeed;
            component.sprintMultiplier = backup.sprintMultiplier;
            component.moveMaxBounces = backup.moveMaxBounces;
            component.moveAnglePower = backup.moveAnglePower;
            component.movePushPower = backup.movePushPower;
            component.movePushDecay = backup.movePushDecay;
            component.fallMaxBounces = backup.fallMaxBounces;
            component.fallPushPower = backup.fallPushPower;
            component.fallAnglePower = backup.fallAnglePower;
            component.fallPushDecay = backup.fallPushDecay;
            component.characterCenter.x = backup.characterCenter.x;
            component.characterCenter.y = backup.characterCenter.y;
            component.characterCenter.z = backup.characterCenter.z;
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.PredictDeltaDelegate))]
        private static void PredictDelta(IntPtr snapshotData, IntPtr baseline1Data, IntPtr baseline2Data, ref GhostDeltaPredictor predictor)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline1 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline1Data);
            ref var baseline2 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline2Data);
            snapshot.moveSpeed = predictor.PredictInt(snapshot.moveSpeed, baseline1.moveSpeed, baseline2.moveSpeed);
            snapshot.sprintMultiplier = predictor.PredictInt(snapshot.sprintMultiplier, baseline1.sprintMultiplier, baseline2.sprintMultiplier);
            snapshot.moveMaxBounces = predictor.PredictInt(snapshot.moveMaxBounces, baseline1.moveMaxBounces, baseline2.moveMaxBounces);
            snapshot.moveAnglePower = predictor.PredictInt(snapshot.moveAnglePower, baseline1.moveAnglePower, baseline2.moveAnglePower);
            snapshot.movePushPower = predictor.PredictInt(snapshot.movePushPower, baseline1.movePushPower, baseline2.movePushPower);
            snapshot.movePushDecay = predictor.PredictInt(snapshot.movePushDecay, baseline1.movePushDecay, baseline2.movePushDecay);
            snapshot.fallMaxBounces = predictor.PredictInt(snapshot.fallMaxBounces, baseline1.fallMaxBounces, baseline2.fallMaxBounces);
            snapshot.fallPushPower = predictor.PredictInt(snapshot.fallPushPower, baseline1.fallPushPower, baseline2.fallPushPower);
            snapshot.fallAnglePower = predictor.PredictInt(snapshot.fallAnglePower, baseline1.fallAnglePower, baseline2.fallAnglePower);
            snapshot.fallPushDecay = predictor.PredictInt(snapshot.fallPushDecay, baseline1.fallPushDecay, baseline2.fallPushDecay);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CalculateChangeMaskDelegate))]
        private static void CalculateChangeMask(IntPtr snapshotData, IntPtr baselineData, IntPtr bits, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask;
            changeMask = (snapshot.moveSpeed != baseline.moveSpeed) ? 1u : 0;
            changeMask |= (snapshot.sprintMultiplier != baseline.sprintMultiplier) ? (1u<<1) : 0;
            changeMask |= (snapshot.moveMaxBounces != baseline.moveMaxBounces) ? (1u<<2) : 0;
            changeMask |= (snapshot.moveAnglePower != baseline.moveAnglePower) ? (1u<<3) : 0;
            changeMask |= (snapshot.movePushPower != baseline.movePushPower) ? (1u<<4) : 0;
            changeMask |= (snapshot.movePushDecay != baseline.movePushDecay) ? (1u<<5) : 0;
            changeMask |= (snapshot.fallMaxBounces != baseline.fallMaxBounces) ? (1u<<6) : 0;
            changeMask |= (snapshot.fallPushPower != baseline.fallPushPower) ? (1u<<7) : 0;
            changeMask |= (snapshot.fallAnglePower != baseline.fallAnglePower) ? (1u<<8) : 0;
            changeMask |= (snapshot.fallPushDecay != baseline.fallPushDecay) ? (1u<<9) : 0;
            changeMask |= (snapshot.characterCenter_x != baseline.characterCenter_x) ? (1u<<10) : 0;
            changeMask |= (snapshot.characterCenter_y != baseline.characterCenter_y) ? (1u<<10) : 0;
            changeMask |= (snapshot.characterCenter_z != baseline.characterCenter_z) ? (1u<<10) : 0;
            GhostComponentSerializer.CopyToChangeMask(bits, changeMask, startOffset, 11);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.SerializeDelegate))]
        private static void Serialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamWriter writer, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                writer.WritePackedIntDelta(snapshot.moveSpeed, baseline.moveSpeed, compressionModel);
            if ((changeMask & (1 << 1)) != 0)
                writer.WritePackedIntDelta(snapshot.sprintMultiplier, baseline.sprintMultiplier, compressionModel);
            if ((changeMask & (1 << 2)) != 0)
                writer.WritePackedIntDelta(snapshot.moveMaxBounces, baseline.moveMaxBounces, compressionModel);
            if ((changeMask & (1 << 3)) != 0)
                writer.WritePackedIntDelta(snapshot.moveAnglePower, baseline.moveAnglePower, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedIntDelta(snapshot.movePushPower, baseline.movePushPower, compressionModel);
            if ((changeMask & (1 << 5)) != 0)
                writer.WritePackedIntDelta(snapshot.movePushDecay, baseline.movePushDecay, compressionModel);
            if ((changeMask & (1 << 6)) != 0)
                writer.WritePackedIntDelta(snapshot.fallMaxBounces, baseline.fallMaxBounces, compressionModel);
            if ((changeMask & (1 << 7)) != 0)
                writer.WritePackedIntDelta(snapshot.fallPushPower, baseline.fallPushPower, compressionModel);
            if ((changeMask & (1 << 8)) != 0)
                writer.WritePackedIntDelta(snapshot.fallAnglePower, baseline.fallAnglePower, compressionModel);
            if ((changeMask & (1 << 9)) != 0)
                writer.WritePackedIntDelta(snapshot.fallPushDecay, baseline.fallPushDecay, compressionModel);
            if ((changeMask & (1 << 10)) != 0)
                writer.WritePackedFloatDelta(snapshot.characterCenter_x, baseline.characterCenter_x, compressionModel);
            if ((changeMask & (1 << 10)) != 0)
                writer.WritePackedFloatDelta(snapshot.characterCenter_y, baseline.characterCenter_y, compressionModel);
            if ((changeMask & (1 << 10)) != 0)
                writer.WritePackedFloatDelta(snapshot.characterCenter_z, baseline.characterCenter_z, compressionModel);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.DeserializeDelegate))]
        private static void Deserialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamReader reader, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                snapshot.moveSpeed = reader.ReadPackedIntDelta(baseline.moveSpeed, compressionModel);
            else
                snapshot.moveSpeed = baseline.moveSpeed;
            if ((changeMask & (1 << 1)) != 0)
                snapshot.sprintMultiplier = reader.ReadPackedIntDelta(baseline.sprintMultiplier, compressionModel);
            else
                snapshot.sprintMultiplier = baseline.sprintMultiplier;
            if ((changeMask & (1 << 2)) != 0)
                snapshot.moveMaxBounces = reader.ReadPackedIntDelta(baseline.moveMaxBounces, compressionModel);
            else
                snapshot.moveMaxBounces = baseline.moveMaxBounces;
            if ((changeMask & (1 << 3)) != 0)
                snapshot.moveAnglePower = reader.ReadPackedIntDelta(baseline.moveAnglePower, compressionModel);
            else
                snapshot.moveAnglePower = baseline.moveAnglePower;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.movePushPower = reader.ReadPackedIntDelta(baseline.movePushPower, compressionModel);
            else
                snapshot.movePushPower = baseline.movePushPower;
            if ((changeMask & (1 << 5)) != 0)
                snapshot.movePushDecay = reader.ReadPackedIntDelta(baseline.movePushDecay, compressionModel);
            else
                snapshot.movePushDecay = baseline.movePushDecay;
            if ((changeMask & (1 << 6)) != 0)
                snapshot.fallMaxBounces = reader.ReadPackedIntDelta(baseline.fallMaxBounces, compressionModel);
            else
                snapshot.fallMaxBounces = baseline.fallMaxBounces;
            if ((changeMask & (1 << 7)) != 0)
                snapshot.fallPushPower = reader.ReadPackedIntDelta(baseline.fallPushPower, compressionModel);
            else
                snapshot.fallPushPower = baseline.fallPushPower;
            if ((changeMask & (1 << 8)) != 0)
                snapshot.fallAnglePower = reader.ReadPackedIntDelta(baseline.fallAnglePower, compressionModel);
            else
                snapshot.fallAnglePower = baseline.fallAnglePower;
            if ((changeMask & (1 << 9)) != 0)
                snapshot.fallPushDecay = reader.ReadPackedIntDelta(baseline.fallPushDecay, compressionModel);
            else
                snapshot.fallPushDecay = baseline.fallPushDecay;
            if ((changeMask & (1 << 10)) != 0)
                snapshot.characterCenter_x = reader.ReadPackedFloatDelta(baseline.characterCenter_x, compressionModel);
            else
                snapshot.characterCenter_x = baseline.characterCenter_x;
            if ((changeMask & (1 << 10)) != 0)
                snapshot.characterCenter_y = reader.ReadPackedFloatDelta(baseline.characterCenter_y, compressionModel);
            else
                snapshot.characterCenter_y = baseline.characterCenter_y;
            if ((changeMask & (1 << 10)) != 0)
                snapshot.characterCenter_z = reader.ReadPackedFloatDelta(baseline.characterCenter_z, compressionModel);
            else
                snapshot.characterCenter_z = baseline.characterCenter_z;
        }
        #if UNITY_EDITOR || DEVELOPMENT_BUILD
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.ReportPredictionErrorsDelegate))]
        private static void ReportPredictionErrors(IntPtr componentData, IntPtr backupData, ref UnsafeList<float> errors)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.KCCMovementSettings>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.KCCMovementSettings>(backupData, 0);
            int errorIndex = 0;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.moveSpeed - backup.moveSpeed));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.sprintMultiplier - backup.sprintMultiplier));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.moveMaxBounces - backup.moveMaxBounces));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.moveAnglePower - backup.moveAnglePower));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.movePushPower - backup.movePushPower));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.movePushDecay - backup.movePushDecay));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.fallMaxBounces - backup.fallMaxBounces));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.fallPushPower - backup.fallPushPower));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.fallAnglePower - backup.fallAnglePower));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.fallPushDecay - backup.fallPushDecay));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.characterCenter, backup.characterCenter));
            ++errorIndex;
        }
        private static int GetPredictionErrorNames(ref FixedString512 names)
        {
            int nameCount = 0;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("moveSpeed"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("sprintMultiplier"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("moveMaxBounces"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("moveAnglePower"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("movePushPower"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("movePushDecay"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("fallMaxBounces"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("fallPushPower"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("fallAnglePower"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("fallPushDecay"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("characterCenter"));
            ++nameCount;
            return nameCount;
        }
        #endif
    }
}