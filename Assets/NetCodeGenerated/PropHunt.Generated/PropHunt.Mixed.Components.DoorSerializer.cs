//THIS FILE IS AUTOGENERATED BY GHOSTCOMPILER. DON'T MODIFY OR ALTER.
using System;
using AOT;
using Unity.Burst;
using Unity.Networking.Transport;
using Unity.NetCode.LowLevel.Unsafe;
using Unity.Collections.LowLevel.Unsafe;
using Unity.Entities;
using Unity.Collections;
using Unity.NetCode;
using Unity.Transforms;
using Unity.Mathematics;
using PropHunt.Mixed.Components;

namespace PropHunt.Generated
{
    [BurstCompile]
    public struct PropHuntMixedComponentsDoorGhostComponentSerializer
    {
        static GhostComponentSerializer.State GetState()
        {
            // This needs to be lazy initialized because otherwise there is a depenency on the static initialization order which breaks il2cpp builds due to TYpeManager not being initialized yet
            if (!s_StateInitialized)
            {
                s_State = new GhostComponentSerializer.State
                {
                    GhostFieldsHash = 7206354693560987144,
                    ExcludeFromComponentCollectionHash = 0,
                    ComponentType = ComponentType.ReadWrite<PropHunt.Mixed.Components.Door>(),
                    ComponentSize = UnsafeUtility.SizeOf<PropHunt.Mixed.Components.Door>(),
                    SnapshotSize = UnsafeUtility.SizeOf<Snapshot>(),
                    ChangeMaskBits = ChangeMaskBits,
                    SendMask = GhostComponentSerializer.SendMask.Interpolated | GhostComponentSerializer.SendMask.Predicted,
                    SendForChildEntities = 1,
                    CopyToSnapshot =
                        new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyToSnapshot),
                    CopyFromSnapshot =
                        new PortableFunctionPointer<GhostComponentSerializer.CopyToFromSnapshotDelegate>(CopyFromSnapshot),
                    RestoreFromBackup =
                        new PortableFunctionPointer<GhostComponentSerializer.RestoreFromBackupDelegate>(RestoreFromBackup),
                    PredictDelta = new PortableFunctionPointer<GhostComponentSerializer.PredictDeltaDelegate>(PredictDelta),
                    CalculateChangeMask =
                        new PortableFunctionPointer<GhostComponentSerializer.CalculateChangeMaskDelegate>(
                            CalculateChangeMask),
                    Serialize = new PortableFunctionPointer<GhostComponentSerializer.SerializeDelegate>(Serialize),
                    Deserialize = new PortableFunctionPointer<GhostComponentSerializer.DeserializeDelegate>(Deserialize),
                    #if UNITY_EDITOR || DEVELOPMENT_BUILD
                    ReportPredictionErrors = new PortableFunctionPointer<GhostComponentSerializer.ReportPredictionErrorsDelegate>(ReportPredictionErrors),
                    #endif
                };
                #if UNITY_EDITOR || DEVELOPMENT_BUILD
                s_State.NumPredictionErrorNames = GetPredictionErrorNames(ref s_State.PredictionErrorNames);
                #endif
                s_StateInitialized = true;
            }
            return s_State;
        }
        private static bool s_StateInitialized;
        private static GhostComponentSerializer.State s_State;
        public static GhostComponentSerializer.State State => GetState();
        public struct Snapshot
        {
            public int state;
            public float transitionTime;
            public int elapsedTransitionTime;
            public float openedPosition_x;
            public float openedPosition_y;
            public float openedPosition_z;
            public float closedPosition_x;
            public float closedPosition_y;
            public float closedPosition_z;
            public float openedRotation_x;
            public float openedRotation_y;
            public float openedRotation_z;
            public float closedRotation_x;
            public float closedRotation_y;
            public float closedRotation_z;
        }
        public const int ChangeMaskBits = 7;
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyToSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData, snapshotOffset + snapshotStride*i);
                ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.Door>(componentData, componentStride*i);
                ref var serializerState = ref GhostComponentSerializer.TypeCast<GhostSerializerState>(stateData, 0);
                snapshot.state = (int) component.state;
                snapshot.transitionTime = component.transitionTime;
                snapshot.elapsedTransitionTime = (int) math.round(component.elapsedTransitionTime * 100);
                snapshot.openedPosition_x = component.openedPosition.x;
                snapshot.openedPosition_y = component.openedPosition.y;
                snapshot.openedPosition_z = component.openedPosition.z;
                snapshot.closedPosition_x = component.closedPosition.x;
                snapshot.closedPosition_y = component.closedPosition.y;
                snapshot.closedPosition_z = component.closedPosition.z;
                snapshot.openedRotation_x = component.openedRotation.x;
                snapshot.openedRotation_y = component.openedRotation.y;
                snapshot.openedRotation_z = component.openedRotation.z;
                snapshot.closedRotation_x = component.closedRotation.x;
                snapshot.closedRotation_y = component.closedRotation.y;
                snapshot.closedRotation_z = component.closedRotation.z;
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CopyToFromSnapshotDelegate))]
        private static void CopyFromSnapshot(IntPtr stateData, IntPtr snapshotData, int snapshotOffset, int snapshotStride, IntPtr componentData, int componentStride, int count)
        {
            for (int i = 0; i < count; ++i)
            {
                ref var snapshotInterpolationData = ref GhostComponentSerializer.TypeCast<SnapshotData.DataAtTick>(snapshotData, snapshotStride*i);
                ref var snapshotBefore = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotBefore, snapshotOffset);
                ref var snapshotAfter = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotInterpolationData.SnapshotAfter, snapshotOffset);
                float snapshotInterpolationFactor = snapshotInterpolationData.InterpolationFactor;
                ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.Door>(componentData, componentStride*i);
                var deserializerState = GhostComponentSerializer.TypeCast<GhostDeserializerState>(stateData, 0);
                deserializerState.SnapshotTick = snapshotInterpolationData.Tick;
                component.state = (PropHunt.Mixed.Components.DoorState) snapshotBefore.state;
                component.transitionTime = snapshotBefore.transitionTime;
                component.elapsedTransitionTime = snapshotBefore.elapsedTransitionTime * 0.01f;
                component.openedPosition = new float3(snapshotBefore.openedPosition_x, snapshotBefore.openedPosition_y, snapshotBefore.openedPosition_z);
                component.closedPosition = new float3(snapshotBefore.closedPosition_x, snapshotBefore.closedPosition_y, snapshotBefore.closedPosition_z);
                component.openedRotation = new float3(snapshotBefore.openedRotation_x, snapshotBefore.openedRotation_y, snapshotBefore.openedRotation_z);
                component.closedRotation = new float3(snapshotBefore.closedRotation_x, snapshotBefore.closedRotation_y, snapshotBefore.closedRotation_z);
            }
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.RestoreFromBackupDelegate))]
        private static void RestoreFromBackup(IntPtr componentData, IntPtr backupData)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.Door>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.Door>(backupData, 0);
            component.state = backup.state;
            component.transitionTime = backup.transitionTime;
            component.elapsedTransitionTime = backup.elapsedTransitionTime;
            component.openedPosition.x = backup.openedPosition.x;
            component.openedPosition.y = backup.openedPosition.y;
            component.openedPosition.z = backup.openedPosition.z;
            component.closedPosition.x = backup.closedPosition.x;
            component.closedPosition.y = backup.closedPosition.y;
            component.closedPosition.z = backup.closedPosition.z;
            component.openedRotation.x = backup.openedRotation.x;
            component.openedRotation.y = backup.openedRotation.y;
            component.openedRotation.z = backup.openedRotation.z;
            component.closedRotation.x = backup.closedRotation.x;
            component.closedRotation.y = backup.closedRotation.y;
            component.closedRotation.z = backup.closedRotation.z;
        }

        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.PredictDeltaDelegate))]
        private static void PredictDelta(IntPtr snapshotData, IntPtr baseline1Data, IntPtr baseline2Data, ref GhostDeltaPredictor predictor)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline1 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline1Data);
            ref var baseline2 = ref GhostComponentSerializer.TypeCast<Snapshot>(baseline2Data);
            snapshot.state = predictor.PredictInt(snapshot.state, baseline1.state, baseline2.state);
            snapshot.elapsedTransitionTime = predictor.PredictInt(snapshot.elapsedTransitionTime, baseline1.elapsedTransitionTime, baseline2.elapsedTransitionTime);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.CalculateChangeMaskDelegate))]
        private static void CalculateChangeMask(IntPtr snapshotData, IntPtr baselineData, IntPtr bits, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask;
            changeMask = (snapshot.state != baseline.state) ? 1u : 0;
            changeMask |= (snapshot.transitionTime != baseline.transitionTime) ? (1u<<1) : 0;
            changeMask |= (snapshot.elapsedTransitionTime != baseline.elapsedTransitionTime) ? (1u<<2) : 0;
            changeMask |= (snapshot.openedPosition_x != baseline.openedPosition_x) ? (1u<<3) : 0;
            changeMask |= (snapshot.openedPosition_y != baseline.openedPosition_y) ? (1u<<3) : 0;
            changeMask |= (snapshot.openedPosition_z != baseline.openedPosition_z) ? (1u<<3) : 0;
            changeMask |= (snapshot.closedPosition_x != baseline.closedPosition_x) ? (1u<<4) : 0;
            changeMask |= (snapshot.closedPosition_y != baseline.closedPosition_y) ? (1u<<4) : 0;
            changeMask |= (snapshot.closedPosition_z != baseline.closedPosition_z) ? (1u<<4) : 0;
            changeMask |= (snapshot.openedRotation_x != baseline.openedRotation_x) ? (1u<<5) : 0;
            changeMask |= (snapshot.openedRotation_y != baseline.openedRotation_y) ? (1u<<5) : 0;
            changeMask |= (snapshot.openedRotation_z != baseline.openedRotation_z) ? (1u<<5) : 0;
            changeMask |= (snapshot.closedRotation_x != baseline.closedRotation_x) ? (1u<<6) : 0;
            changeMask |= (snapshot.closedRotation_y != baseline.closedRotation_y) ? (1u<<6) : 0;
            changeMask |= (snapshot.closedRotation_z != baseline.closedRotation_z) ? (1u<<6) : 0;
            GhostComponentSerializer.CopyToChangeMask(bits, changeMask, startOffset, 7);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.SerializeDelegate))]
        private static void Serialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamWriter writer, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                writer.WritePackedIntDelta(snapshot.state, baseline.state, compressionModel);
            if ((changeMask & (1 << 1)) != 0)
                writer.WritePackedFloatDelta(snapshot.transitionTime, baseline.transitionTime, compressionModel);
            if ((changeMask & (1 << 2)) != 0)
                writer.WritePackedIntDelta(snapshot.elapsedTransitionTime, baseline.elapsedTransitionTime, compressionModel);
            if ((changeMask & (1 << 3)) != 0)
                writer.WritePackedFloatDelta(snapshot.openedPosition_x, baseline.openedPosition_x, compressionModel);
            if ((changeMask & (1 << 3)) != 0)
                writer.WritePackedFloatDelta(snapshot.openedPosition_y, baseline.openedPosition_y, compressionModel);
            if ((changeMask & (1 << 3)) != 0)
                writer.WritePackedFloatDelta(snapshot.openedPosition_z, baseline.openedPosition_z, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedFloatDelta(snapshot.closedPosition_x, baseline.closedPosition_x, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedFloatDelta(snapshot.closedPosition_y, baseline.closedPosition_y, compressionModel);
            if ((changeMask & (1 << 4)) != 0)
                writer.WritePackedFloatDelta(snapshot.closedPosition_z, baseline.closedPosition_z, compressionModel);
            if ((changeMask & (1 << 5)) != 0)
                writer.WritePackedFloatDelta(snapshot.openedRotation_x, baseline.openedRotation_x, compressionModel);
            if ((changeMask & (1 << 5)) != 0)
                writer.WritePackedFloatDelta(snapshot.openedRotation_y, baseline.openedRotation_y, compressionModel);
            if ((changeMask & (1 << 5)) != 0)
                writer.WritePackedFloatDelta(snapshot.openedRotation_z, baseline.openedRotation_z, compressionModel);
            if ((changeMask & (1 << 6)) != 0)
                writer.WritePackedFloatDelta(snapshot.closedRotation_x, baseline.closedRotation_x, compressionModel);
            if ((changeMask & (1 << 6)) != 0)
                writer.WritePackedFloatDelta(snapshot.closedRotation_y, baseline.closedRotation_y, compressionModel);
            if ((changeMask & (1 << 6)) != 0)
                writer.WritePackedFloatDelta(snapshot.closedRotation_z, baseline.closedRotation_z, compressionModel);
        }
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.DeserializeDelegate))]
        private static void Deserialize(IntPtr snapshotData, IntPtr baselineData, ref DataStreamReader reader, ref NetworkCompressionModel compressionModel, IntPtr changeMaskData, int startOffset)
        {
            ref var snapshot = ref GhostComponentSerializer.TypeCast<Snapshot>(snapshotData);
            ref var baseline = ref GhostComponentSerializer.TypeCast<Snapshot>(baselineData);
            uint changeMask = GhostComponentSerializer.CopyFromChangeMask(changeMaskData, startOffset, ChangeMaskBits);
            if ((changeMask & (1 << 0)) != 0)
                snapshot.state = reader.ReadPackedIntDelta(baseline.state, compressionModel);
            else
                snapshot.state = baseline.state;
            if ((changeMask & (1 << 1)) != 0)
                snapshot.transitionTime = reader.ReadPackedFloatDelta(baseline.transitionTime, compressionModel);
            else
                snapshot.transitionTime = baseline.transitionTime;
            if ((changeMask & (1 << 2)) != 0)
                snapshot.elapsedTransitionTime = reader.ReadPackedIntDelta(baseline.elapsedTransitionTime, compressionModel);
            else
                snapshot.elapsedTransitionTime = baseline.elapsedTransitionTime;
            if ((changeMask & (1 << 3)) != 0)
                snapshot.openedPosition_x = reader.ReadPackedFloatDelta(baseline.openedPosition_x, compressionModel);
            else
                snapshot.openedPosition_x = baseline.openedPosition_x;
            if ((changeMask & (1 << 3)) != 0)
                snapshot.openedPosition_y = reader.ReadPackedFloatDelta(baseline.openedPosition_y, compressionModel);
            else
                snapshot.openedPosition_y = baseline.openedPosition_y;
            if ((changeMask & (1 << 3)) != 0)
                snapshot.openedPosition_z = reader.ReadPackedFloatDelta(baseline.openedPosition_z, compressionModel);
            else
                snapshot.openedPosition_z = baseline.openedPosition_z;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.closedPosition_x = reader.ReadPackedFloatDelta(baseline.closedPosition_x, compressionModel);
            else
                snapshot.closedPosition_x = baseline.closedPosition_x;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.closedPosition_y = reader.ReadPackedFloatDelta(baseline.closedPosition_y, compressionModel);
            else
                snapshot.closedPosition_y = baseline.closedPosition_y;
            if ((changeMask & (1 << 4)) != 0)
                snapshot.closedPosition_z = reader.ReadPackedFloatDelta(baseline.closedPosition_z, compressionModel);
            else
                snapshot.closedPosition_z = baseline.closedPosition_z;
            if ((changeMask & (1 << 5)) != 0)
                snapshot.openedRotation_x = reader.ReadPackedFloatDelta(baseline.openedRotation_x, compressionModel);
            else
                snapshot.openedRotation_x = baseline.openedRotation_x;
            if ((changeMask & (1 << 5)) != 0)
                snapshot.openedRotation_y = reader.ReadPackedFloatDelta(baseline.openedRotation_y, compressionModel);
            else
                snapshot.openedRotation_y = baseline.openedRotation_y;
            if ((changeMask & (1 << 5)) != 0)
                snapshot.openedRotation_z = reader.ReadPackedFloatDelta(baseline.openedRotation_z, compressionModel);
            else
                snapshot.openedRotation_z = baseline.openedRotation_z;
            if ((changeMask & (1 << 6)) != 0)
                snapshot.closedRotation_x = reader.ReadPackedFloatDelta(baseline.closedRotation_x, compressionModel);
            else
                snapshot.closedRotation_x = baseline.closedRotation_x;
            if ((changeMask & (1 << 6)) != 0)
                snapshot.closedRotation_y = reader.ReadPackedFloatDelta(baseline.closedRotation_y, compressionModel);
            else
                snapshot.closedRotation_y = baseline.closedRotation_y;
            if ((changeMask & (1 << 6)) != 0)
                snapshot.closedRotation_z = reader.ReadPackedFloatDelta(baseline.closedRotation_z, compressionModel);
            else
                snapshot.closedRotation_z = baseline.closedRotation_z;
        }
        #if UNITY_EDITOR || DEVELOPMENT_BUILD
        [BurstCompile]
        [MonoPInvokeCallback(typeof(GhostComponentSerializer.ReportPredictionErrorsDelegate))]
        private static void ReportPredictionErrors(IntPtr componentData, IntPtr backupData, ref UnsafeList<float> errors)
        {
            ref var component = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.Door>(componentData, 0);
            ref var backup = ref GhostComponentSerializer.TypeCast<PropHunt.Mixed.Components.Door>(backupData, 0);
            int errorIndex = 0;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.state - backup.state));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.transitionTime - backup.transitionTime));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.abs(component.elapsedTransitionTime - backup.elapsedTransitionTime));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.openedPosition, backup.openedPosition));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.closedPosition, backup.closedPosition));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.openedRotation, backup.openedRotation));
            ++errorIndex;
            errors[errorIndex] = math.max(errors[errorIndex], math.distance(component.closedRotation, backup.closedRotation));
            ++errorIndex;
        }
        private static int GetPredictionErrorNames(ref FixedString512 names)
        {
            int nameCount = 0;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("state"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("transitionTime"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("elapsedTransitionTime"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("openedPosition"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("closedPosition"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("openedRotation"));
            ++nameCount;
            if (nameCount != 0)
                names.Append(new FixedString32(","));
            names.Append(new FixedString64("closedRotation"));
            ++nameCount;
            return nameCount;
        }
        #endif
    }
}